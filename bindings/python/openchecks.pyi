import enum
from collections.abc import Callable, Iterable
from typing import Generic, TypeVar

_T = TypeVar("_T")

class Status(enum.Enum):
    Pending = enum.auto()
    Skipped = enum.auto()
    Passed = enum.auto()
    Warning = enum.auto()
    Failed = enum.auto()
    SystemError = enum.auto()

    def is_pending(self) -> bool: ...
    def has_passed(self) -> bool: ...
    def has_failed(self) -> bool: ...

class Item(Generic[_T]):
    def __init__(
        self,
        value: _T,
        type_hint: str | None = None,
    ) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: Item[_T]) -> bool: ...
    def __le__(self, other: Item[_T]) -> bool: ...
    def __gt__(self, other: Item[_T]) -> bool: ...
    def __ge__(self, other: Item[_T]) -> bool: ...
    def value(self) -> _T: ...
    def type_hint(self) -> str | None: ...

class CheckResult(Generic[_T]):
    def __init__(
        self,
        status: Status,
        message: str,
        items: Iterable[Item[_T]] | None = None,
        can_fix: bool = False,
        can_skip: bool = False,
        error: BaseException | None = None,
    ) -> None: ...
    def status(self) -> Status: ...
    def message(self) -> str: ...
    def items(self) -> list[Item[_T]] | None: ...
    def can_fix(self) -> bool: ...
    def can_skip(self) -> bool: ...
    def error(self) -> CheckError | None: ...
    def check_duration(self) -> float: ...
    def fix_duration(self) -> float: ...
    @staticmethod
    def passed(
        message: str,
        items: Iterable[Item[_T]] | None = None,
        can_fix: bool = False,
        can_skip: bool = False,
    ) -> CheckResult: ...
    @staticmethod
    def skipped(
        message: str,
        items: Iterable[Item[_T]] | None = None,
        can_fix: bool = False,
        can_skip: bool = False,
    ) -> CheckResult: ...
    @staticmethod
    def warning(
        message: str,
        items: Iterable[Item[_T]] | None = None,
        can_fix: bool = False,
        can_skip: bool = False,
    ) -> CheckResult: ...
    @staticmethod
    def failed(
        message: str,
        items: Iterable[Item[_T]] | None = None,
        can_fix: bool = False,
        can_skip: bool = False,
    ) -> CheckResult: ...

class CheckHint(enum.Flag):
    NONE = 0b0
    AUTO_FIX = enum.auto()

    @staticmethod
    def all() -> CheckHint: ...

class CheckMetadata(Generic[_T]):
    def title(self) -> str: ...
    def description(self) -> str: ...
    def hint(self) -> CheckHint: ...

class BaseCheck(CheckMetadata, Generic[_T]):
    def check(self) -> CheckResult[_T]: ...
    def auto_fix(self) -> None: ...

class AsyncBaseCheck(CheckMetadata, Generic[_T]):
    async def async_check(self) -> CheckResult[_T]: ...
    async def async_auto_fix(self) -> None: ...

class CheckError(Exception): ...

class DiscoveryRegistry(Generic[_T]):
    def register(
        self, query: Callable[[_T], bool], generator: Callable[[_T], list[BaseCheck]]
    ) -> None: ...
    def register_async(
        self,
        query: Callable[[_T], bool],
        generator: Callable[[_T], list[AsyncBaseCheck]],
    ) -> None: ...
    def gather(self, context: _T) -> list[BaseCheck] | None: ...
    def gather_async(self, context: _T) -> list[AsyncBaseCheck] | None: ...

def run(check: BaseCheck[_T]) -> CheckResult[_T]: ...
def auto_fix(check: BaseCheck[_T]) -> CheckResult[_T]: ...
async def async_run(check: AsyncBaseCheck[_T]) -> CheckResult[_T]: ...
async def async_auto_fix(check: AsyncBaseCheck[_T]) -> CheckResult[_T]: ...

class BaseScheduler(Generic[_T]):
    def run(
        self, checks: Iterable[BaseCheck[_T]]
    ) -> list[tuple[BaseCheck[_T], CheckResult[_T]]]: ...
    def auto_fix(
        self, check: Iterable[BaseCheck[_T]]
    ) -> list[tuple[BaseCheck[_T], CheckResult[_T]]]: ...

class AsyncBaseScheduler(Generic[_T]):
    async def async_run(
        self, checks: Iterable[AsyncBaseCheck[_T]]
    ) -> list[tuple[BaseCheck[_T], CheckResult[_T]]]: ...
    async def async_auto_fix(
        self, check: Iterable[AsyncBaseCheck[_T]]
    ) -> list[tuple[BaseCheck[_T], CheckResult[_T]]]: ...

class Scheduler(BaseScheduler[_T]): ...
